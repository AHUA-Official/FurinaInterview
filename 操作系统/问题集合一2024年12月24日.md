#### 进程线程

```
进程是资源分配和调度的基本单位。
线程是程序执行的最小单位，线程是进程的子任务，是进程内的执行单元。 一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存。
资源开销：
● 进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。 
● 线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需要保存和恢复少量的线程上下文，因此上下文切换的开销较小。 
通信与同步：
● 进程：由于进程间相互隔离，进程之间的通信需要使用一些特殊机制，如管道、消息队列、共享内存等。
● 线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加方便。
安全性： 
● 进程：由于进程间相互隔离，一个进程的崩溃不会直接影响其他进程的稳定性。 
● 线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。
```

#### 并行并发

```
● 并行是在同一时刻执行多个任务。
● 并发是在相同的时间段内执行多个任务，任务可能交替执行，通过调度实现。
并行是指在同一时刻执行多个任务，这些任务可以同时进行，每个任务都在不同的处理单元（如多个CPU核心）上执行。在并行系统中，多个处理单元可以同时处理独立的子任务，从而加速整体任务的完成。
并发是指在相同的时间段内执行多个任务，这些任务可能不是同时发生的，而是交替执行，通过时间片轮转或者事件驱动的方式。并发通常与任务之间的交替执行和任务调度有关。
```

#### 用户空间 /内核空间

```
1. 用户态和内核态的区别
用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种不同的CPU运行级别，可以控制进程或程序对计算机硬件资源的访问权限和操作范围。
● 用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源。
● 核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。
1. 在什么场景下，会发生内核态和用户态的切换
● 系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态。
● 异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。
● 中断：外部设备（如键盘、鼠标、磁盘等）产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态。
```

#### 进程调度算法

```
● 先来先服务：按照请求的顺序进行调度。 这种调度方式简单，但是能导致较长作业阻塞较短作业。
● 最短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。 但是如果一直有短作业到来，那么长作业永远得不到调度，造成长作业“饥饿”现象。
● 最短剩余时间优先：基于最短作业优先改进，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
● 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 
● 时间片轮转：为每个进程分配一个时间片，进程轮流执行，时间片用完后切换到下一个进程
```

#### 进程通信方式

```
1. 管道：是一种半双工的通信方式，数据只能单向流动而且只能在具有父子进程关系的进程间使用。 
2. 命名管道： 类似管道，也是半双工的通信方式，但是它允许在不相关的进程间通信。 
3. 消息队列：允许进程发送和接收消息，而消息队列是消息的链表，可以设置消息优先级。
4. 信号：用于发送通知到进程，告知其发生了某种事件或条件。
5. 信号量：是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同一进程内不同线程之间的同步手段。
6. 共享内存：就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的进程通信方式，
7. Socket套接字：是支持TCP/IP 的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。
8. 互斥锁：一种信号量，用于保护共享数据结构，防止多个进程同时访问。
9. 条件变量：与互斥锁配合使用，用于进程间的同步，等待某些条件成立
```

#### 进程同步和互斥

```
进程同步是指多个并发执行的进程之间协调和管理它们的执行顺序，以确保它们按照一定的顺序或时间间隔执行。
互斥指的是在某一时刻只允许一个进程访问某个共享资源。当一个进程正在使用共享资源时，其他进程不能同时访问该资源。
解决进程同步和互斥的问题有很多种方法，其中一种常见的方法是使用信号量和 PV 操作。信号量是一种特殊的变量，它表示系统中某种资源的数量或者状态。PV 操作是一种对信号量进行增加或者减少的操作，它们可以用来控制进程之间的同步或者互斥。
● P操作：相当于“检查”信号量，如果资源可用，就减少计数，然后使用资源。
● V操作：相当于“归还”资源，增加信号量的计数，并可能唤醒等待的进程。
除此之外，下面的方法也可以解决进程同步和互斥问题：
● 临界区：将可能引发互斥问题的代码段称为临界区，里面包含了需要互斥访问的资源。进入这个区域前需要先获取锁，退出临界区后释放该锁。这确保同一时间只有一个进程可以进入临界区。
● 互斥锁（Mutex）：互斥锁是一种同步机制，用于实现互斥。每个共享资源都关联一个互斥锁，进程在访问该资源前需要先获取互斥锁，使用完后释放锁。只有获得锁的进程才能访问共享资源。
● 条件变量：条件变量用于在进程之间传递信息，以便它们在特定条件下等待或唤醒。通常与互斥锁一起使用，以确保等待和唤醒的操作在正确的时机执行。
```

#### 死锁

```
死锁是系统中两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一定的资源并等待其他进程释放它们所需的资源时，如果这些资源都被其他进程占有且不释放，就导致了死锁。
死锁只有同时满足以下四个条件才会发生： 
● 互斥条件：一个进程占用了某个资源时，其他进程无法同时占用该资源。 
● 请求保持条件：一个线程因为请求资源而阻塞的时候，不会释放自己的资源。
● 不可剥夺条件：资源不能被强制性地从一个进程中剥夺，只能由持有者自愿释放。 
● 循环等待条件：多个进程之间形成一个循环等待资源的链，每个进程都在等待下一个进程所占有的资源。
避免死锁：通过破坏死锁的四个必要条件之一来预防死锁。比如破坏循环等待条件，让所有进程按照相同的顺序请求资源。检测死锁：通过检测系统中的资源分配情况来判断是否存在死锁。例如，可以使用资源分配图或银行家算法进行检测。解除死锁：一旦检测到死锁存在，可以采取一些措施来解除死锁。例如，可以通过抢占资源、终止某些进程或进行资源回收等方式来解除死锁。
```

#### 银行家算法

```
当一个新进程进入系统时，必须声明需要每种资源的最大数目，其数目不能超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程，若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会才将资源分配给它，否则让进程等待。
```

#### 虚拟内存

```
虚拟内存是指在每一个进程创建加载的过程中，会分配一个连续虚拟地址空间，它不是真实存在的，而是通过映射与实际物理地址空间对应，这样就可以使每个进程看起来都有自己独立的连续地址空间，并允许程序访问比物理内存RAM更大的地址空间, 每个程序都可以认为它拥有足够的内存来运行。
需要虚拟内存的原因：
● 内存扩展： 虚拟内存使得每个程序都可以使用比实际可用内存更多的内存，从而允许运行更大的程序或处理更多的数据。
● 内存隔离：虚拟内存还提供了进程之间的内存隔离。每个进程都有自己的虚拟地址空间，因此一个进程无法直接访问另一个进程的内存。
● 物理内存管理：虚拟内存允许操作系统动态地将数据和程序的部分加载到物理内存中，以满足当前正在运行的进程的需求。当物理内存不足时，操作系统可以将不常用的数据或程序暂时移到硬盘上，从而释放内存，以便其他进程使用。
● 页面交换：当物理内存不足时，操作系统可以将一部分数据从物理内存写入到硬盘的虚拟内存中，这个过程被称为页面交换。当需要时，数据可以再次从虚拟内存中加载到物理内存中。这样可以保证系统可以继续运行，尽管物理内存有限。
● 内存映射文件：虚拟内存还可以用于将文件映射到内存中，这使得文件的读取和写入可以像访问内存一样高效。 
```

#### 线程同步

```
线程同步机制是指在多线程编程中，为了保证线程之间的互不干扰，而采用的一种机制。常见的线程同步机制有以下几种： 
1. 互斥锁：互斥锁是最常见的线程同步机制。它允许只有一个线程同时访问被保护的临界区（共享资源）
2. 条件变量：条件变量用于线程间通信，允许一个线程等待某个条件满足，而其他线程可以发出信号通知等待线程。通常与互斥锁一起使用。 
3. 读写锁： 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。 
4. 信号量：用于控制多个线程对共享资源进行访问的工具。
```

#### 锁

```
● 互斥锁：互斥锁是一种最常见的锁类型，用于实现互斥访问共享资源。在任何时刻，只有一个线程可以持有互斥锁，其他线程必须等待直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源。
● 自旋锁：自旋锁是一种基于忙等待的锁，即线程在尝试获取锁时会不断轮询，直到锁被释放。
其他的锁都是基于这两个锁的 
● 读写锁：允许多个线程同时读共享资源，只允许一个线程进行写操作。分为读（共享）和写（排他）两种状态。
● 悲观锁：认为多线程同时修改共享资源的概率比较高，所以访问共享资源时候要上锁 
● 乐观锁：先不管，修改了共享资源再说，如果出现同时修改的情况，再放弃本次操作。
```

页面置换

```
常见页面置换算法有最佳置换算法（OPT）、先进先出（FIFO）、最近最久未使用算法（LRU）、时钟算法（Clock） 等。
1. 最近最久未使用算法LRU ：LRU算法基于页面的使用历史，通过选择最长时间未被使用的页面进行置换。
2. 先进先出FIFO算法：也就是最先进入内存的页面最先被置换出去。
3. 最不经常使用LFU ：淘汰访问次数最少的页面，考虑页面的访问频率。
4. 时钟算法CLOCK：Clock算法的核心思想是通过使用一个指针(称为时钟指针)在环形链表上遍历，检查页面是否被访问过, 当需要进行页面置换时，Clock算法从时钟指针的位置开始遍历环形链表。 如果当前页面的访问位为0，表示该页面最久未被访问，可以选择进行置换。将访问位设置为1，继续遍历下一个页面。 如果当前页面的访问位为1，表示该页面最近被访问过，它仍然处于活跃状态。将访问位设置为0，并继续遍历下一个页面如果遍历过程中找到一个访问位为0的页面，那么选择该页面进行置换。
5. 最佳置换算法: 该算法根据未来的页面访问情况，选择最长时间内不会被访问到的页面进行置换。那么就有一个问题了，未来要访问什么页面，操作系统怎么知道的呢?操作系统当然不会知道，所以这种算法只是一种理想情况下的置换算法，通常是无法实现的
```

#### IO多路复用

```
I/O多路复用通常通过select、poll、epoll等系统调用来实现。
● select： select是一个最古老的I/O多路复用机制，它可以监视多个文件描述符的可读、可写和错误状态。然而，但是它的效率可能随着监视的文件描述符数量的增加而降低。
● poll： poll是select的一种改进，它使用轮询方式来检查多个文件描述符的状态，避免了select中文件描述符数量有限的问题。但对于大量的文件描述符，poll的性能也可能变得不足够高效。
● epoll： epoll是Linux特有的I/O多路复用机制，相较于select和poll，它在处理大量文件描述符时更加高效。epoll使用事件通知的方式，只有在文件描述符就绪时才会通知应用程序，而不需要应用程序轮询。
I/O多路复用允许在一个线程中处理多个I/O操作，避免了创建多个线程或进程的开销，允许在一个线程中处理多个I/O操作，避免了创建多个线程或进程的开销。
```

